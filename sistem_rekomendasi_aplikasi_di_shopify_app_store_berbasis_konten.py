# -*- coding: utf-8 -*-
"""Sistem Rekomendasi Aplikasi di Shopify App Store Berbasis Konten.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DSTL94oPy_hv8C5nHBDJ-GhjM8p5J1Hv

Name: Muhammad Rizky
Program: DBS Program

**Sistem Rekomendasi Aplikasi di Shopify App Store Berbasis Konten**

Proyek ini bertujuan untuk membangun sistem rekomendasi aplikasi yang dapat memberikan saran aplikasi serupa kepada pengguna berdasarkan konten teks pada aplikasi di Shopify App Store. Dengan memberikan rekomendasi aplikasi yang sesuai, sistem ini diharapkan dapat meningkatkan kepuasan pengguna dalam memilih aplikasi yang tepat untuk kebutuhan bisnis mereka.

**Problem Domain**

Sistem rekomendasi harus berfokus pada optimalisasi pencarian dan pemilihan aplikasi oleh pengguna. Dengan ribuan aplikasi yang tersedia, pengguna sering kali kesulitan menemukan aplikasi yang sesuai untuk kebutuhan bisnis mereka. Sistem rekomendasi berbasis konten ini bertujuan untuk mempermudah proses tersebut dengan menyarankan aplikasi serupa berdasarkan deskripsi dan fitur utama. Dengan demikian, sistem ini dapat meningkatkan pengalaman pengguna di Shopify App Store dan membantu mereka menemukan aplikasi yang paling relevan secara lebih efisien.

**Business Understanding**

Bisnis dari proyek ini adalah untuk meningkatkan pengalaman pengguna dalam mencari aplikasi di Shopify App Store melalui sistem rekomendasi berbasis konten. Dengan menyarankan aplikasi serupa yang relevan berdasarkan deskripsi dan fitur aplikasi, sistem ini dapat membantu pengguna menemukan aplikasi yang sesuai dengan kebutuhan mereka dengan lebih cepat dan mudah. Dampak positif dari sistem rekomendasi ini meliputi peningkatan kepuasan pengguna, waktu pencarian yang lebih efisien, dan kemungkinan konversi yang lebih tinggi bagi aplikasi yang disarankan.

**Import Package Libarray**
"""

!pip install kaggle
#Libarary untuk upload File
from google.colab import files
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
# Train-test split for collaborative filtering
from sklearn.model_selection import train_test_split
# Handle text-based features for Content-Based Filtering
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.decomposition import TruncatedSVD
from sklearn.metrics import mean_squared_error

files.upload()

!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json

!kaggle datasets download -d r usernam3/shopify-app-store
!unzip shopify-app-store.zip

"""**Data Understanding**

Tahapan ini untuk memahami struktur data yang ada di dataset
"""

import pandas as pd

# Membaca dataset aplikasi
df_apps = pd.read_csv("apps.csv")

# Melihat beberapa baris dari dataset
df_apps.head()

# Mengetahui informasi dataset
df_apps.info()

# Melihat statistik deskriptif
df_apps.describe()

# Menampilkan jumlah baris dan kolom dalam dataset
jumlah_baris, jumlah_kolom = df_apps.shape
print("Jumlah data (baris):", jumlah_baris)
print("Jumlah fitur (kolom):", jumlah_kolom)

#Mengecheck data duplikat
data_duplicate = df_apps.duplicated().sum()
if data_duplicate > 0:
  print(f"Jumlah data duplikat {data_duplicate}")
else:
  print("Tidak ada data duplikat")

missing_values = df_apps.isnull().sum()
total_missing = missing_values.sum()

if total_missing > 0:
  print(f"Jumlah data yang hilang: {total_missing}")
else:
  print("Tidak ada missing value")

"""**Univariate Exploratory Data Analysis**

Analisis ini bertujuan untuk memahami distribusi variabel tertentu seperti rating dan reviews_count. Anda dapat menggunakan sns.histplot() untuk melihat pola distribusi data.

Distribusi Berdasarkan Rating: Menunjukkan sebaran rating aplikasi yang diulas, memberi gambaran tentang kualitas rata-rata aplikasi di platform Shopify.
"""

import matplotlib.pyplot as plt
import seaborn as sns

# Visualisasi distribusi rating
plt.figure(figsize=(10, 5))
sns.histplot(df_apps['rating'], bins=20, kde=True)
plt.title('Distribusi Rating Aplikasi')
plt.xlabel('Rating')
plt.ylabel('Frekuensi')
plt.savefig('distribusi_rating.png')
plt.show()

"""Distribusi Berdasarkan Jumlah Ulasan: Distribusi ulasan membantu mengidentifikasi aplikasi yang paling populer berdasarkan interaksi pengguna."""

# Visualisasi jumlah ulasan
plt.figure(figsize=(10, 5))
sns.histplot(df_apps['reviews_count'], bins=20, kde=True)
plt.title('Distribusi Jumlah Ulasan Aplikasi')
plt.xlabel('Jumlah Ulasan')
plt.ylabel('Frekuensi')
plt.savefig('distribusi_ulasan.png')
plt.show()

"""**Data Preparation**

Tahapan Data Preprocessing untuk menangani nilai hilang dan menghapus data duplikat. Menangani nilai yang hilang bisa dengan rata-rata atau median.
"""

# Menangani nilai yang hilang
df_apps.fillna({'rating': df_apps['rating'].mean()}, inplace=True)# Mengisi nilai hilang pada rating dengan rata-rata

# Memeriksa nilai duplikat
df_apps.drop_duplicates(subset='title', keep='first', inplace=True)

"""Pada tahap ini, Anda akan menggabungkan kolom teks yang relevan, seperti title, description, dan tagline menjadi satu kolom content untuk representasi yang lebih kaya."""

from sklearn.feature_extraction.text import TfidfVectorizer

# 1. Membuat Kolom Konten
df_apps['content'] = df_apps['title'] + " " + df_apps['description'] + " " + df_apps['tagline']

# 2. Text Preprocessing dan Vectorization
vector = TfidfVectorizer(stop_words='english', ngram_range=(1, 2), max_df=0.9, min_df=0.2)
matrix_vector = vector.fit_transform(df_apps['content'])

"""**Model Development**

Tahap modeling di sini menggunakan cosine_similarity untuk mengukur kesamaan antar aplikasi berdasarkan teks content. Fungsi rekomendasi mencari aplikasi-aplikasi yang paling mirip dengan input.
"""

from sklearn.metrics.pairwise import cosine_similarity
import pandas as pd
# 3. Menghitung Cosine Similarity
cosine_sim = cosine_similarity(matrix_vector, matrix_vector)

# 4. Fungsi Rekomendasi
def recommend_apps(app_title, cosine_sim=cosine_sim, df_apps=df_apps):
    try:
        # Mendapatkan index aplikasi berdasarkan judul
        app_title = df_apps[df_apps['title'] == app_title].index[0]

        # Mendapatkan skor similarity untuk semua aplikasi
        sim_scores = list(enumerate(cosine_sim[app_title]))

        # Mengurutkan aplikasi berdasarkan skor similarity
        sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)

        # Mengambil aplikasi dengan similarity tertinggi (kecuali aplikasi itu sendiri)
        sim_scores = sim_scores[1:12]  # Ambil 10 teratas

        # Mendapatkan judul aplikasi yang mirip
        title_similirarity = [i[0] for i in sim_scores]
        simililarity_scores = [round(i[1] * 100, 2) for i in sim_scores]

        recommended_apps = pd.DataFrame({
            'judul': df_apps['title'].iloc[title_similirarity].values,
            'Kemiripan (%)': simililarity_scores
        })
        print("Daftar Rekomendasi Produk Berdasarkan Kemiripan\n")
        print(recommended_apps.to_markdown(index=False))
        # Mengembalikan rekomendasi judul aplikasi
        return recommended_apps
    except IndexError:
        return "Tidak Memiliki Rekomendasi"

"""**Evaluation Model**

menampilkan hasil rekomendasi beserta kemiripannya  dengan model yang telah di buat
"""

#Penggunaan
recommend_app = 'JewelExchange Product Feed API'
recommendations = recommend_apps(recommend_app)

"""**Evaluation Model dengan matrix Precision at K, Recall at K**

precision at k: Menghitung berapa banyak rekomendasi yang relevan di antara K rekomendasi teratas, dinyatakan dalam persen.
recall at k: Menghitung berapa banyak item relevan yang ter-rekomendasi di antara K rekomendasi teratas terhadap total item relevan, juga dalam bentuk persen.
"""

# Precision at K Function
def precision_at_k(recommendations, relate_apps, k=5):
    precision_recommend = recommendations['judul'].head(k).tolist()
    precision_relevant = len([app for app in precision_recommend if app in relate_apps])
    return (precision_relevant / k) * 100

def recall_at_k(recommendations, relate_apps, k=10):
    recall_recommend = recommendations['judul'].head(k).tolist()
    recall_relevant = len([app for app in recall_recommend if app in relate_apps])
    return (recall_relevant / len(relate_apps)) * 100


# Mendapatkan rekomendasi
data_recommend = recommend_apps(recommend_app)

# Menentukan relate_apps otomatis berdasarkan ambang batas kemiripan 75%
similarity_threshold = 75
actual_relate_app = data_recommend[data_recommend['Kemiripan (%)'] >= similarity_threshold]['judul'].tolist()

# Menghitung Precision@K dan Recall@K
precision_percent = precision_at_k(data_recommend, actual_relate_app, k=5)
recall_percent = recall_at_k(data_recommend, actual_relate_app, k=5)

print(f"Precision at 5: {precision_percent:.2f}%")
print(f"Recall at 5: {recall_percent:.2f}%")

"""**Kesimpulan**

Kesimpulan dari proyek sistem rekomendasi aplikasi Shopify ini menunjukkan bahwa pendekatan berbasis konten dapat secara efektif mengidentifikasi aplikasi yang memiliki kesamaan fitur atau fungsi yang tinggi, sesuai dengan kebutuhan pengguna. Dengan menghitung kemiripan menggunakan Cosine Similarity, sistem ini mampu memberikan daftar rekomendasi aplikasi dengan tingkat kemiripan tertentu, membantu pengguna menemukan aplikasi yang relevan tanpa harus mencari secara manual. Evaluasi yang dilakukan melalui metrik precision dan recall menunjukkan seberapa baik model ini dalam merekomendasikan aplikasi yang benar-benar relevan, meskipun tantangan seperti ketersediaan data perilaku pengguna tetap menjadi keterbatasan.
"""